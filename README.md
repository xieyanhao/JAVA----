JAVA----
========

接触一门新的技术和初恋一样，都是第一次，但不同的是后者一般开始无比甜蜜，结局却很痛苦，而前者则往往开始很痛苦，越到后来却越是有味
    一般来说安装完JDK之后，一定要按一下步骤配置，才可正确编译运行(假定jdk版本为1.4.0)。 

　　1.将jdk1.4.0-安装在自己机器的某个盘符的根目录下，如：可安装在C:\jdk下。 

　　***(以下出现的c:\jdk改为你自己安装JDK的目录)*** 

　　2.如果你的运行环境是win98，则在C盘根目录下，autoexec.bat文件中，加入下面两条语句： 

　　set Path=%PATH%;c:\jdk\bin 
　　set CLASSPATH=.;c:\jdk\lib\dt.jar;c:\jdk\lib\tools.jar保存后，重新启动机器，就完成了jdk1.4的安装。 

　　3.如果你的运行环境是win2000的话，则需在“控制面板”的“系统”下，“高级”选项的“环境变量”中，添加两个用户变量。 

　　其中一个用户变量的名称为“path”，值为“.;d:\j2sdk1.4.0_01\bin”，另一个用户变量的名称为"CLASSPATH"，值为“.;d"\j2sdk1.4.0_01\lib\dt.jar;d:\j2sdk1.4.0_01\lib\tools.jar”，单击“确定”即可。即完成了jdk1.4.0的安装。 

　　至于这样做的意义何在，我想应该是让Java系统在编译字节代码(.java)的时候需要一个什么东东的支持，如果你不告诉它这个东东放在哪个地方的话，它就犯傻了?! 

　　看到屏幕上终于显示出Hello world对我来说意义重大.这是我近一年来写的第一个程序!再次踏上程序之路，简直有恍如隔世的感觉，已经快找不准我的位置了。还好原来学的一些关于C++和面向对象的皮毛没忘光光，所以费点周折熟悉了JDK的环境之后，接下来的事情就好办多了，心里也踏实多了。 

　　用String类直接定义字符串变量比起C中讨厌的指针，感觉确实好的多，用惯了Object Pascal的我，如果再回去数* *，真要疯掉不可。 

　　数组的定义和C，C++好像略有不同，记不清了，先记下来再说 

　　int[] number=new int[5] 
　　String[] message=new String[5] 

　　变量这一部分想起来要交待的也就这么多吧。虽然是菜鸟，但我也知道，总是如谭浩强般在语法上面死抠的人简直是白痴:大多数情况下，漂亮的程序根本不需要无谓的点缀，工工整整，思路清晰就可以了。 

　　倒是对于Java程序的框架我倒想备忘一下，一个简单的java程序好像是应该是这样的框架： 

　　class ProgramName 
　　{ 
　　public static void main(String【】 args) 
　　{ 
　　file&://程序的主体 
　　} 

　　public static int othermethod() 
　　{ 
　　file&://其它方法 
　　} 
　　} 

　　整个程序在一个大的类中，这个类的概念应该就跟pascal里面的单元差不多的。同pascal一样，文件名也要与单元名-在这里是类名-一样.Java对大小写要求的非常严格，我语法错了好几次都是因为这个. 

　　Java程序就是由一个或者多个或者很多个方法在这样一个大类当中组成的. 

　　在如上的代码中，定义方法的参数表示的意思分别为: 

　　public表示此成员函数是公有的，可以被其他类直接调用 static表示main成员函数在ProgramName类的所有对象中是唯一的，Java将为其分配永久存储空间 

　　关于Static，我想再延伸一下。有时候我们创建一个类，希望这个类的所有实例都公用一个变量，也就是说，所有这个类的对象都只有实例变量的一个Copy.那么这样一个静态实例变量的内存就不能在创建类的实例的时候分配了，因为大家用的都是这么一个，不需要再重新分配.因此Java为其分配永久存储空间。 

　　比如： 

　　class Block{ 
　　static int number=50 
　　} 

　　这样定义之后，所有Block类的实例，不管是Block1，还是Block2，它们都访问同一个number.这个number叫做类的变量，而不是实例变量.实际上静态变量又叫做类变量。 

　　继续深入：用Static定义的静态成员函数或者静态变量，可以通过其所属类名来直接调用.为什么可以这样?因为既然这个类的所有对象都是使用的这一个变量，那么理所当然我不需要去从其中的任何一个对象去引用它，而只是通过类名引用就可以了嘛.这样不是可以方便的实现一些全局函数和全局变量吗?把所有全局的函数或者全局的变量都定义在一个静态类中，调用的时候直接通过这一个类名就可以方便的访问所有的全局变量和全局函数了。 

　　定义所有程序都要访问的全局变量需要使用 

　　public final static 

　　另外碰到一个初学者经常会遇到的问题 

　　non-static variable mainframe cannot be referenced from a static context 

　　即在静态方法中不能引用非静态变量 

　　为什么？ 

　　因为我们知道静态的方法可以在没有创建实例时使用，而申明为非静态的成员变量是一个对象属性，它只有在对象存在时引用，因此如果在对象未创建实例时我们在静态方法中调用了非静态成员方法自然是非法的，所以编译器会在这种时候给各错误. 

　　简单说来，静态方法可以不用创建对象就调用，非静态方法必须有了对象的实例才能调用.因此想在静态方法中引用非静态方法是不可能的，因为它究竟引用的是哪个对象的非静态方法呢?编译器不可能给出答案，因为没有对象啊，所以要报错. 

　　最后我们看看Think in Java里面的精辟阐述，这个问题我想就非常非常的清楚了 

　　static关键字 

　　通常，我们创建类时会指出那个类的对象的外观与行为。除非用new创建那个类的一个对象，否则实际上并未得到任何东西。只有执行了new后，才会正式生成数据存储空间，并可使用相应的方法。 

　　但在两种特殊的情形下，上述方法并不堪用。一种情形是只想用一个存储区域来保存一个特定的数据——无论要创建多少个对象，甚至根本不创建对象。另一种情形是我们需要一个特殊的方法，它没有与这个类的任何对象关联。也就是说，即使没有创建对象，也需要一个能调用的方法。为满足这两方面的要求，可使用static（静态）关键字。一旦将什么东西设为static，数据或方法就不会同那个类的任何对象实例联系到一起。所以尽管从未创建那个类的一个对象，仍能调用一个static方法，或访问一些static数据。而在这之前，对于非static数据和方法，我们必须创建一个对象，并用那个对象访问数据或方法。这是由于非static数据和方法必须知道它们操作的具体对象。当然，在正式使用前，由于static方法不需要创建任何对象，所以它们不可简单地调用其他那些成员，同时不引用一个已命名的对象，从而直接访问非static成员或方法（因为非static成员和方法必须同一个特定的对象关联到一起）。 

　　Whoops！现在应该回到主干上来了 

　　void 表示方法返回的值的类型为空。如果返回特定的类型的话，则该方法实际上就是函数，否则就是一个过程而已.
